\subsection{Type Preservation of the Translation}

The translation from the implicit language
to the explicit language preserves typing:
\begin{theorem}[Translation Preserves Typing\label{thm:translationtyping}]
    \coq{desugaring\_typing}
        If $\typingi{\Gamma}{\hat{N}}{\hat{A}}$, then
            $\typing{\ctxofictx{\Gamma}}{\trmofitrm{\hat{N}}}{\typofityp{\hat{A}}}$,
            where
    a typing context $\ctxofictx{\Gamma}$ is obtained by replacing
    each binding of the form $x:\hat{A}$ in $\Gamma$ with $x:\typofityp{\hat{A}}$.
\end{theorem}
\begin{proof}
    The proof is by induction on the derivation of
        $\typingi{\Gamma}{\hat{N}}{\hat{A}}$.
        The \rn{Imp-Abs} rule is parameterized by an
        arbitrary fresh variable $x$, so the case for this rule requires to prove
        a conclusion that holds for \emph{any} such fresh $x$. To do so, we need to
        show that the translation function $\trmofitrm{\cdot}$
        commutes with $\alpha$-renaming of variables.
        In fact, we prove a stronger result, that this
        function commutes with substitution of an arbitrary term for a
        free variable, which we show below in \Cref{lem:substcommutes}.
        All other cases are straightforward.
\end{proof}

\begin{lemma}[Substitution Commutes With Translation\label{lem:substcommutes}]
    \coq{open\_trm\_of\_itrm}
        \item $\trmofitrm{\subst{\hat{N}}{\hat{x}}{\hat{M}}} = \subst{\trmofitrm{\hat{N}}}{x}{\trmofitrm{\hat{M}}}$
\end{lemma}
\begin{proof}
    The proof is by straightforward induction on the structure of $\hat{N}$.
\end{proof}

\section{Interoperability\label{sec:interop}}

In this section, we will explore how terms of the explicit language
can use terms of the implicit language and vice versa.

\subsection{Implicit Terms within Explicit Terms}

To use a term $\hat{M}$ of the implicit language within the explicit
language, we just translate the term first, and use
$\trmofitrm{\hat{M}}$ within the explicit language.
However, the translated term has an inconvenient type,
so it cannot be used directly.
For example, the translated implicit language constant term 
$\trmofitrm{\hat{c}}$ has the nullable type $\iota?$, so it cannot be an operand of
the explicit language $\oplus$ operator, which requires operands of type $\iota$. Similarly,
the translated implicit language function term $\trmofitrm{\abs{x}{\hat{A}}{\hat{N}}}$ has the nullable type
$\arrowP{\typofityp{\hat{A}}}{\typofityp{\hat{B}}}?$
(where $\hat{B}$
is a type of the body $\hat{N}$), so it cannot be used directly in a function
application.

One safe solution is to explicitly handle the possibility of
an implicit language subterm evaluating to null using the \code{case}
construct. In $\case{\trmofitrm{\hat{c}}}{N}{x}{M}$, the constant $\hat{c}$
is available in $M$ through the variable $x$ with the convenient type $\iota$.
More complicated types require additional pattern matching. For example,
a pattern match can extract a term of function type 
$\arrow{\typofityp{\hat{A}}}{\typofityp{\hat{B}}}$
from one of nullable type
$\arrowP{\typofityp{\hat{A}}}{\typofityp{\hat{B}}}?$,
but additional lifts and pattern matching are required to
deal with the remaining nullable types $\typofityp{\hat{A}}$ and $\typofityp{\hat{B}}$.
Although inconvenient, this approach is safe: since it uses only pattern matches
but no casts, there are no casts that could fail.
% (except for the null checks
% $\blop$ and $\blderef$ associated with operations in the implicit sublanguage).

If we are confident that the implicit language subterm will not evaluate to
null, a more convenient approach is to cast it to a more suitable type.
We define a \emph{naive} translation of implicit types as follows:
\begin{align*}
\typofitypn{\iota} &= \iota\\
\typofitypn{\arrow{\hat{A}}{\hat{B}}} &= \arrow{\typofitypn{\hat{A}}}{\typofitypn{\hat{B}}}
\end{align*}
The naive translation maps a constant type of the implicit language
to a constant type of the core language and it maps a function type
of the implicit language to a function type of the core language.
Thus, given a term $\hat{N}$ of type $\hat{A}$ in the implicit
language, we can use it directly in the explicit language if we
embed it using the following cast:
$$\cast{\trmofitrm{\hat{N}}}{\typofityp{\hat{A}}}{\blie}{\typofitypn{\hat{A}}}$$
Here, the blame label $\blie$ stands for a cast from the implicit language to the explicit language.

This is convenient but unsafe, since the cast could fail. However,
the cast can fail only with positive blame, blaming the implicit language
subterm $\trmofitrm{\hat{N}}$ rather than the surrounding explicit language context.
This is because 
$\typofitypn{\hat{A}}$ is a naive subtype of
$\typofityp{\hat{A}}$:
\begin{lemma}
    For every implicit type $\hat{A}$, $\subtypn{\typofitypn{\hat{A}}}{\typofityp{\hat{A}}}$.
\end{lemma}
\begin{proof}
    The proof is by straightforward induction on the structure of $\hat{A}$.
\end{proof}
Then by the Tangram Lemma, $\subtypneg{\typofityp{\hat{A}}}{\typofitypn{\hat{A}}}$,
so a term containing this form of cast is safe for $\overline{\blie}$,
so it cannot reduce to $\blame{\overline{\blie}}$.

\subsection{Explicit Terms within Implicit Terms}

It is also possible to embed an explicit language term within an implicit
language term by applying the translation to the surrounding implicit term.
The general pattern is $\code{let } x:A = M \code{ in } \trmofitrm{\hat{N}}$,
which can be desugared as $\app{\absP{x}{A}{\trmofitrm{\hat{N}}}}{M}$.

However, we must again adapt the types.
Typing the implicit language term $\hat{N}$ requires a typing context
that binds $x$ to some implicit language type $\hat{B}$. By
\Cref{thm:translationtyping}, the translated term $\trmofitrm{\hat{N}}$
can be typed in a translated context $\ctxofictx{\Gamma}$ that
binds $x$ to $\typofityp{\hat{B}}$. Thus, the overall
lambda abstraction $\app{\absP{x}{A}{\trmofitrm{\hat{N}}}}{M}$
can be typed as long as there is some $\hat{B}$ such that
$A = \typofityp{\hat{B}}$, in other words, as long as the
explicit language type $A$ of $M$
is the image of some implicit type $\hat{B}$ under the translation.

For an explicit term
$M$ of base type $\iota$, this is easy to achieve using just lifting, since
$\lift{M}$ has type $\iota? = \typofityp{\iota}$. For an explicit term of function type,
however, ensuring that its type is the image of some implicit
language type requires adjusting its domain and codomain types.
Specifically, if the domain type of an explicit language function
is a definite (non-null) type, pattern matching needs to be added
before applying the function to handle the case that the actual
argument from the implicit language could be null.
Although it is possible to use a term of the explicit language
in the implicit language without adding any casts, it may require
adding multiple lifts and pattern matching, and is thus inconvenient.

If we are confident about lack of null references, we can again
use a cast to conveniently allow an explicit language term of any
type to be embedded in the implicit language. To do so, we first define
the \emph{erasure} of an explicit language type to be the implicit language type
determined as follows:
\begin{align*}
    \itypoftyp{D?} &= \itypoftyp{D} \\
    \itypoftyp{\iota} &= \iota \\
    \itypoftyp{\arrow{A}{B}} &= \arrow{\itypoftyp{A}}{\itypoftyp{B}}
\end{align*}
Then for any explicit type $A$, the translation of its erasure $\typofityp{\itypoftyp{A}}$ is the
image of an implicit language type. Therefore, any explicit term $M$ of any explicit type $A$ can be embedded in an implicit language term $\hat{N}$ using the following pattern:
$$\app{\absP{x}{\typofityp{\itypoftyp{A}}}{\trmofitrm{\hat{N}}}}{\castP{M}{A}{\blei}{\typofityp{\itypoftyp{A}}}}$$

Here, the blame label $\blei$ stands for a cast from the explicit language to the implicit language.

Again, this is convenient but unsafe, since the cast may fail.
However, the cast may fail only with \emph{negative} blame, placing the
blame on the implicit language context. For example, if the type $A$
is a function type with a non-null domain type, the cast could fail if the surrounding
implicit context invokes the function with a null argument.
The cast cannot fail with positive blame because
$A$ is a naive subtype of $\typofityp{\itypoftyp{A}}$:
\begin{lemma}
    For every explicit type $A$, $\subtypn{A}{\typofityp{\itypoftyp{A}}}$.
\end{lemma}
\begin{proof}
    The proof is by straightforward induction on the structure of $A$.
\end{proof}
Then by the Tangram Lemma, 
$\subtyppos{A}{\typofityp{\itypoftyp{A}}}$,
so a term containing this form of cast is safe for $\blei$,
so it cannot reduce to $\blame{\blei}$.
