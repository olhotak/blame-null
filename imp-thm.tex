\section{Properties}

In this section, we show two important properties of the two-sublanguage calculus.
First, we show that the translation defined in the previous section
preserves typing: if a term in the implicit sublanguage or the explicit
sublanguage can be typed using the rules from \Cref{fig:imptyping}, then
the corresponding term translated to the core calculus can also be given
the corresponding type.
Second, we show a form of blame safety, that the only way in which a
term in the range of the translation can fail is due to one of the
null checks in the implicit language.

\subsection{Type Preservation of the Translation}

Recall that typing contexts $\Gamma$ for the two-sublanguage calculus bind
each variable either to a type $\hat{A}$ in the implicit sublanguage or to
a type $A$ in the explicit sublanguage, but typing contexts $\Gamma$ in the core
calculus bind each variable to a type $A$ in the core calculus. Therefore,
in order to state the theorem that the translation preserves types, we must
first define a translation from typing contexts for the two-sublanguage
calculus to typing contexts for the core calculus:

\begin{definition}[Translation of Typing Contexts]
    \coq{ctx\_of\_ictx}\\
    A typing context $\ctxofictx{\Gamma}$ is obtained by replacing
    each binding of the form $x:\hat{A}$ in $\Gamma$ with $x:\typofityp{\hat{A}}$
    and keeping each binding of the form $x:A$ unchanged.
\end{definition}

We can now formulate the type preservation theorem as follows, for typings
of terms $\hat{N}$ in the implicit sublanguage and terms $N$ in the explicit sublanguage.

\begin{theorem}[Translation Preserves Typing\label{thm:translationtyping}]
    \coq{desugaring\_typing}
    \begin{enumerate}
        \item If $\typing{\Gamma}{\hat{N}}{\hat{A}}$, then
            $\typing{\ctxofictx{\Gamma}}{\trmofitrm{\hat{N}}}{\typofityp{\hat{A}}}$.
        \item If $\typing{\Gamma}{N}{A}$ (according to the typing rules of \Cref{fig:imptyping}), then
            $\typing{\ctxofictx{\Gamma}}{\trmofetrm{N}}{A}$ (according to the typing rules of \Cref{fig:typing}).
    \end{enumerate}
\end{theorem}
\begin{proof}
    The proof is by mutual induction on the derivations of the typings
        $\typing{\Gamma}{\hat{N}}{\hat{A}}$
        and
        $\typing{\ctxofictx{\Gamma}}{\trmofetrm{N}}{A}$.
        The \rn{Abs}, \rn{Case}, and \rn{Imp-Abs} rules are each parameterized by an
        arbitrary fresh variable $x$, so the cases for these rules require to prove
        a conclusion that holds for \emph{any} such fresh $x$. To do so, we need to
        show that the translation functions $\trmofitrm{\cdot}$
        and $\trmofetrm{\cdot}$ commute with $\alpha$ renaming of variables.
        In fact, we prove a stronger result, that these
        two functions commute with substitution of an arbitrary term for a
        free variable, which we show below in \Cref{lem:substcommutes}.
        All other cases are straightforward.
\end{proof}

\begin{lemma}[Substitution Commutes With Translation\label{lem:substcommutes}]
    \coq{open\_trm\_of\_ietrm}
    \begin{enumerate}
        \item $\trmofitrm{\subst{\hat{N}}{\hat{x}}{\hat{M}}} = \subst{\trmofitrm{\hat{N}}}{x}{\trmofitrm{\hat{M}}}$
        \item $\trmofetrm{\subst{N}{x}{M}} = \subst{\trmofetrm{N}}{x}{\trmofetrm{M}}$
    \end{enumerate}
\end{lemma}
\begin{proof}
    The proof is by straightforward mutual induction on the structure of $\hat{N}$ and $N$.
\end{proof}



\subsection{Interoperability}

The two-sublanguage calculus allows an implicit language term to be used in the
explicit language, but with an inconvenient type, so it cannot be used directly.
For example, the constant term 
$\itrm{\hat{c}}$ has the nullable type $\iota?$, so it cannot be an operand of
the $\oplus$ operator, which requires operands of type $\iota$. Similarly,
the constant function term $\itrm{\abs{x}{\hat{A}}{\hat{N}}}$ has the nullable type
$\arrowP{\typofityp{\hat{A}}}{\typofityp{\hat{B}}}?$
(where $\hat{B}$
is a type of the body $\hat{N}$), so it cannot be used directly in a function
application.

One obviously safe solution is to explicitly handle the possibility of
an implicit-language subterm evaluating to null using the \code{case}
construct. In $\case{\itrm{\hat{c}}}{N}{x}{M}$, the constant $\hat{c}$
is available in $M$ through the variable $x$ with the convenient type $\iota$.
More complicated types require additional pattern matching. For example,
a $\code{case}$ term can extract a value of function type 
$\arrow{\typofityp{\hat{A}}}{\typofityp{\hat{B}}}$
from one of nullable type
$\arrowP{\typofityp{\hat{A}}}{\typofityp{\hat{B}}}?$,
but additional lifts and pattern matching are required to
deal with the remaining nullable types $\typofityp{\hat{A}}$ and $\typofityp{\hat{B}}$.
Although inconvenient, this approach is safe: if we do not use
any casts, there are no casts that could fail (except for the null checks
$\blop$ and $\blderef$ associated with operations in the implicit sublanguage).

If we are confident that the implicit-language subterm will not evaluate to
null, a more convenient approach is to cast it to a more suitable type.
We define a \emph{naive} translation of implicit types as follows:
\begin{align*}
\typofitypn{\iota} &= \iota\\
\typofitypn{\arrow{\hat{A}}{\hat{B}}} &= \arrow{\typofitypn{\hat{A}}}{\typofitypn{\hat{B}}}
\end{align*}
The naive translation maps a constant type of the implicit language
to a constant type of the core language, and it maps a function type
of the implicit language to a function type of the core language.
Thus, given a term $\hat{N}$ of type $\hat{A}$ in the implicit
language, we can use it directly in the explicit language if we
embed it using the following cast:
$$\cast{\itrm{\hat{N}}}{\typofityp{\hat{A}}}{\blie}{\typofitypn{\hat{A}}}$$

This is convenient but unsafe, since the cast could fail. However,
the cast can fail only with positive blame, blaming the implicit language
subterm $\hat{N}$ rather than the surrounding explicit language context.
This is because 
$\typofitypn{\hat{A}}$ is a naive subtype of
$\typofityp{\hat{A}}$:
\begin{lemma}
    For every implicit type $\hat{A}$, $\subtypn{\typofitypn{\hat{A}}}{\typofityp{\hat{A}}}$.
\end{lemma}
\TODO{prove here and in Coq}
Then by the Tangram Lemma, $\subtypneg{\typofityp{\hat{A}}}{\typofitypn{\hat{A}}}$,
so a term containing this form of cast is safe for $\overline{\blie}$,
so it cannot reduce to $\blame{\overline{\blie}}$.


Conversely, it is possible to use a term of the explicit language in
the implicit language, but we must again adapt the types. According to the
typing rule \rn{Imp-Exp}, an embedding $\etrm{M}$ can be typed only if the
explicit language term $M$ has a type $\typofityp{\hat{A}}$ that is the
image of some implicit language type $\hat{A}$ under the tranlation
$\typofityp{\cdot}$ of implicit types. For an explicit term
$N$ of base type $\iota$, this is easy to achieve using just lifting, since
$\lift{N}$ has type $\iota? = \typofityp{\iota}$. For an explicit term of function type,
however, ensuring that its type is the image of some implicit
language type requires adjusting its domain and codomain types.
Specifically, if the domain type of an explicit-language function
is a definite (non-null type), pattern matching needs to be added
before applying the function to handle the case that the actual
argument from the implicit language could be null.
Although it is possible to use a term of the explicit language
in the implicit language without adding any casts, it may require
adding multiple lifts and pattern matching, and is thus inconvenient.

If we are confident about lack of null references, we can again
use a cast to conveniently allow an explicit-language term of any
type to be embedded in the implicit language. To do so, we first define
the \emph{erasure} of an explicit-language type to be the implicit-language type
determined as follows:
\begin{align*}
    \itypoftyp{D?} &= \itypoftyp{D} \\
    \itypoftyp{\iota} &= \iota \\
    \itypoftyp{\arrow{A}{B}} &= \arrow{\itypoftyp{A}}{\itypoftyp{B}}
\end{align*}
Then \emph{any} explicit term $M$ of \emph{any} explicit type $A$ can be embedded
in the implicit language using the following cast:
$$\etrm{\cast{M}{A}{\blei}{\typofityp{\itypoftyp{A}}}}$$

Again, this is convenient but unsafe, since the cast may fail.
However, the cast may fail only with \emph{negative} blame, placing the
blame on the implicit-language context. For example, if the $A$
is a function type with a non-null domain type, the cast could fail if the surrounding
implicit context invokes the function with a null argument.
The cast cannot fail with positive blame because
$A$ is a naive subtype of $\typofityp{\itypoftyp{A}}$:
\begin{lemma}
    For every implicit type $\hat{A}$, $\subtypn{A}{\typofityp{\itypoftyp{A}}}$.
\end{lemma}
\TODO{prove here and in Coq}
Then by the Tangram Lemma, 
$\subtyppos{A}{\typofityp{\itypoftyp{A}}}$,
so a term containing this form of cast is safe for $\blei$,
so it cannot reduce to $\blame{\blei}$.
