\section{An Implicitly Nullable Language\label{sec:impdefn}}

Having defined an explicit language with casts (like Scala), we now define
an implicit language that ignores nullability in its types (like Java).

\subsection{Syntax}

The syntax of implicit languages is defined in \Cref{fig:impsyntax}.
In general, we use a $\hat{\text{hat}}$ to mark elements of the implicit language.
The syntax of terms of the implicit language $\hat{L}, \hat{M}, \hat{N}$
mirrors that of the explicit language, but omits lifting, pattern matching, casts, and blame,
since those are useless without the distinction between nullable and non-null
types.

\input{fig/impsyntax}

Types $\hat{A}, \hat{B}, \hat{C}$ of the implicit language are not distinguished
as nullable or non-null. All types in the implicit language admit the null constant.

\TODO{Consider changing the notation for types from the implicit
    language to write them \emph{always} with question marks: $\iota?$ and
    $\arrowP{A}{B}?$.
}

\subsection{Typing}

The typing rules of the implicit language are standard, and are shown in \Cref{fig:imptyping}.
The $\hat{\code{null}}$ constant can have any type $\hat{A}$.

\input{fig/imptyping}

\subsection{Semantics}

We define the semantics of the implicit language by translation
to the explicit language, whose operational semantics we defined in
\Cref{sec:defn}. The translation is presented in \Cref{fig:translation}.

\input{fig/translation}

Types of the implicit language are translated to types in the explicit
language that are equivalent in that 
they admit equivalent sets
of values: in particular, the translated types admit the null constant.

In the translation of terms of the implicit language, we will
make frequent use of pattern matching. We introduce as shorthand
an Elvis operator $\elvis{M}{N}$ that takes a term $M$ of nullable type $D?$
and reduces to $N$ when $M$ evaluates to $\code{null}$
and to $V$ when $M$ evaluates to $\lift{V}$.

Variable references and the null constant are just translated to
themselves. Base constants $\hat{c}$, base operations $\binop{\hat{N}}{\hat{M}}$,
and function abstractions $\abs{x}{\hat{A}}{\hat{M}}$ have types
in the implicit language that translate to nullable types in the
explicit language, so these terms are translated to lifted terms
in the explicit language. The translation of a base operation $\oplus$
uses the Elvis operator to check the whether the operands
$\hat{N}$ and $\hat{M}$ are null before performing the operation $\oplus$.
The blame label $\blop$ is used to signal that a null check in a
base operation failed. Similarly, the translation of a function
application $\app{\hat{N}}{\hat{M}}$ first checks whether $\hat{N}$
(the function) evaluates to null before evaluating the argument
$\hat{M}$ and performing the application.
